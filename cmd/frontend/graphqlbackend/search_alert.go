package graphqlbackend

import (
	"context"
	"fmt"
	"path"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode"

	"github.com/sourcegraph/sourcegraph/cmd/frontend/backend"
	"github.com/sourcegraph/sourcegraph/cmd/frontend/envvar"
	"github.com/sourcegraph/sourcegraph/internal/database/dbutil"
	"github.com/sourcegraph/sourcegraph/internal/search"
	"github.com/sourcegraph/sourcegraph/internal/search/alert"
	"github.com/sourcegraph/sourcegraph/internal/search/query"
	searchrepos "github.com/sourcegraph/sourcegraph/internal/search/repos"
	"github.com/sourcegraph/sourcegraph/internal/search/run"
	"github.com/sourcegraph/sourcegraph/internal/search/searchcontexts"
)

type searchAlertResolver struct {
	alert.Alert
}

func (a searchAlertResolver) PrometheusType() string { return a.Alert.PrometheusType }

func (a searchAlertResolver) Title() string { return a.Alert.Title }

func (a searchAlertResolver) Description() *string {
	if a.Alert.Description == "" {
		return nil
	}
	return &a.Alert.Description
}

func (a searchAlertResolver) ProposedQueries() *[]searchQueryDescriptionResolver {
	if len(a.Alert.ProposedQueries) == 0 {
		return nil
	}
	resolvers := make([]searchQueryDescriptionResolver, 0, len(a.Alert.ProposedQueries))
	for _, query := range a.Alert.ProposedQueries {
		resolvers = append(resolvers, searchQueryDescriptionResolver{query})
	}
	return &resolvers
}

func alertForCappedAndExpression() *alert.Alert {
	return &alert.Alert{
		PrometheusType: "exceed_and_expression_search_limit",
		Title:          "Too many files to search for expression",
		Description:    "One expression in the query requires a lot of work! This can happen with negated text searches like '-content:', not-expressions, or and-expressions. Try using the '-file:' or '-repo:' filters to narrow your search (like excluding autogenerated files). We're working on improving this experience in https://github.com/sourcegraph/sourcegraph/issues/9824",
	}
}

// alertForQuery converts errors in the query to search alerts.
func alertForQuery(queryString string, err error) *alert.Alert {
	switch err.(type) {
	case *query.UnsupportedError, *query.ExpectedOperand:
		return &alert.Alert{
			PrometheusType: "unsupported_and_or_query",
			Title:          "Unable To Process Query",
			Description:    `I'm having trouble understanding that query. Your query contains "and" or "or" operators that make me think they apply to filters like "repo:" or "file:". We only support "and" or "or" operators on search patterns for file contents currently. You can help me by putting parentheses around the search pattern.`,
		}
	}
	return &alert.Alert{
		PrometheusType: "generic_invalid_query",
		Title:          "Unable To Process Query",
		Description:    capFirst(err.Error()),
	}
}

func alertForTimeout(usedTime time.Duration, suggestTime time.Duration, r *searchResolver) *alert.Alert {
	q, err := query.ParseLiteral(r.rawQuery()) // Invariant: query is already validated; guard against error anyway.
	if err != nil {
		return &alert.Alert{
			PrometheusType: "timed_out",
			Title:          "Timed out while searching",
			Description:    fmt.Sprintf("We weren't able to find any results in %s. Try adding timeout: with a higher value.", usedTime.Round(time.Second)),
		}
	}
	return &alert.Alert{
		PrometheusType: "timed_out",
		Title:          "Timed out while searching",
		Description:    fmt.Sprintf("We weren't able to find any results in %s.", usedTime.Round(time.Second)),
		ProposedQueries: []alert.ProposedQuery{
			{
				Description: "query with longer timeout",
				Query:       fmt.Sprintf("timeout:%v %s", suggestTime, query.OmitField(q, query.FieldTimeout)),
				PatternType: r.PatternType,
			},
		},
	}
}

func alertForStalePermissions() *alert.Alert {
	return &alert.Alert{
		PrometheusType: "no_resolved_repos__stale_permissions",
		Title:          "Permissions syncing in progress",
		Description:    "Permissions are being synced from your code host, please wait for a minute and try again.",
	}
}

// reposExist returns true if one or more repos resolve. If the attempt
// returns 0 repos or fails, it returns false. It is a helper function for
// raising NoResolvedRepos alerts with suggestions when we know the original
// query does not contain any repos to search.
func (r *searchResolver) reposExist(ctx context.Context, options searchrepos.Options) bool {
	options.UserSettings = r.UserSettings
	repositoryResolver := &searchrepos.Resolver{
		DB:               r.db,
		Zoekt:            r.zoekt,
		DefaultReposFunc: backend.Repos.ListDefault,
	}
	resolved, err := repositoryResolver.Resolve(ctx, options)
	return err == nil && len(resolved.RepoRevs) > 0
}

func (r *searchResolver) alertForNoResolvedRepos(ctx context.Context) *alert.Alert {
	globbing := getBoolPtr(r.UserSettings.SearchGlobbing, false)

	repoFilters, minusRepoFilters := r.Query.Repositories()
	repoGroupFilters, _ := r.Query.StringValues(query.FieldRepoGroup)
	contextFilters, _ := r.Query.StringValues(query.FieldContext)
	onlyForks, noForks, forksNotSet := false, false, true
	if fork := r.Query.Fork(); fork != nil {
		onlyForks = *fork == query.Only
		noForks = *fork == query.No
		forksNotSet = false
	}
	archived := r.Query.Archived()
	archivedNotSet := archived == nil

	// Handle repogroup-only scenarios.
	if len(repoFilters) == 0 && len(repoGroupFilters) == 0 {
		return &alert.Alert{
			PrometheusType: "no_resolved_repos__no_repositories",
			Title:          "Add repositories or connect repository hosts",
			Description:    "There are no repositories to search. Add an external service connection to your code host.",
		}
	}
	if len(repoFilters) == 0 && len(repoGroupFilters) == 1 {
		return &alert.Alert{
			PrometheusType: "no_resolved_repos__repogroup_empty",
			Title:          fmt.Sprintf("Add repositories to repogroup:%s to see results", repoGroupFilters[0]),
			Description:    fmt.Sprintf("The repository group %q is empty. See the documentation for configuration and troubleshooting.", repoGroupFilters[0]),
		}
	}
	if len(repoFilters) == 0 && len(repoGroupFilters) > 1 {
		return &alert.Alert{
			PrometheusType: "no_resolved_repos__repogroup_none_in_common",
			Title:          "Repository groups have no repositories in common",
			Description:    "No repository exists in all of the specified repository groups.",
		}
	}
	if len(contextFilters) == 1 && !searchcontexts.IsGlobalSearchContextSpec(contextFilters[0]) && (len(repoFilters) > 0 || len(repoGroupFilters) > 0) {
		withoutContextFilter := query.OmitField(r.Query, query.FieldContext)
		proposedQueries := []alert.ProposedQuery{{
			Description: "search in the global context",
			Query:       fmt.Sprintf("context:%s %s", searchcontexts.GlobalSearchContextName, withoutContextFilter),
			PatternType: r.PatternType,
		}}

		return &alert.Alert{
			PrometheusType:  "no_resolved_repos__context_none_in_common",
			Title:           fmt.Sprintf("No repositories found for your query within the context %s", contextFilters[0]),
			ProposedQueries: proposedQueries,
		}
	}

	// TODO(sqs): handle -repo:foo fields.

	withoutRepoFields := query.OmitField(r.Query, query.FieldRepo)

	switch {
	case len(repoGroupFilters) > 1:
		// This is a rare case, so don't bother proposing queries.
		return &alert.Alert{
			PrometheusType: "no_resolved_repos__more_than_one_repogroup",
			Title:          "No repository exists in all specified groups and satisfies all of your repo: filters.",
			Description:    "Expand your repository filters to see results",
		}

	case len(repoGroupFilters) == 1 && len(repoFilters) > 1:
		if globbing {
			return &alert.Alert{
				PrometheusType: "no_resolved_repos__try_remove_filters_for_repogroup",
				Title:          fmt.Sprintf("No repositories in repogroup:%s satisfied all of your repo: filters.", repoGroupFilters[0]),
				Description:    "Remove repo: filters to see results",
			}
		}
		proposedQueries := []alert.ProposedQuery{}
		tryRemoveRepoGroup := searchrepos.Options{
			RepoFilters:      repoFilters,
			MinusRepoFilters: minusRepoFilters,
			OnlyForks:        onlyForks,
			NoForks:          noForks,
		}
		if r.reposExist(ctx, tryRemoveRepoGroup) {
			proposedQueries = []alert.ProposedQuery{
				{
					Description: fmt.Sprintf("include repositories outside of repogroup:%s", repoGroupFilters[0]),
					Query:       query.OmitField(r.Query, query.FieldRepoGroup),
					PatternType: r.PatternType,
				},
			}
		}

		unionRepoFilter := searchrepos.UnionRegExps(repoFilters)
		tryAnyRepo := searchrepos.Options{
			RepoFilters:      []string{unionRepoFilter},
			MinusRepoFilters: minusRepoFilters,
			RepoGroupFilters: repoGroupFilters,
			OnlyForks:        onlyForks,
			NoForks:          noForks,
		}
		if r.reposExist(ctx, tryAnyRepo) {
			proposedQueries = append(proposedQueries, alert.ProposedQuery{
				Description: "include repositories satisfying any (not all) of your repo: filters",
				Query:       withoutRepoFields + fmt.Sprintf(" repo:%s", unionRepoFilter),
				PatternType: r.PatternType,
			})
		} else {
			// Fall back to removing repo filters.
			proposedQueries = append(proposedQueries, alert.ProposedQuery{
				Description: "remove repo: filters",
				Query:       withoutRepoFields,
				PatternType: r.PatternType,
			})
		}

		return &alert.Alert{
			PrometheusType:  "no_resolved_repos__try_remove_filters_for_repogroup",
			Title:           fmt.Sprintf("No repositories in repogroup:%s satisfied all of your repo: filters.", repoGroupFilters[0]),
			Description:     "Expand your repository filters to see results",
			ProposedQueries: proposedQueries,
		}

	case len(repoGroupFilters) == 1 && len(repoFilters) == 1:
		if globbing {
			return &alert.Alert{
				PrometheusType: "no_resolved_repogroups",
				Title:          fmt.Sprintf("No repositories in repogroup:%s satisfied all of your repo: filters.", repoGroupFilters[0]),
				Description:    "Remove repo: filters to see results",
			}
		}
		proposedQueries := []alert.ProposedQuery{}
		tryRemoveRepoGroup := searchrepos.Options{
			RepoFilters:      repoFilters,
			MinusRepoFilters: minusRepoFilters,
			OnlyForks:        onlyForks,
			NoForks:          noForks,
		}
		if r.reposExist(ctx, tryRemoveRepoGroup) {
			proposedQueries = []alert.ProposedQuery{
				{
					Description: fmt.Sprintf("include repositories outside of repogroup:%s", repoGroupFilters[0]),
					Query:       query.OmitField(r.Query, query.FieldRepoGroup),
					PatternType: r.PatternType,
				},
			}
		}

		proposedQueries = append(proposedQueries, alert.ProposedQuery{
			Description: "remove repo: filters",
			Query:       withoutRepoFields,
			PatternType: r.PatternType,
		})
		return &alert.Alert{
			PrometheusType:  "no_resolved_repogroups",
			Title:           fmt.Sprintf("No repositories in repogroup:%s satisfied all of your repo: filters.", repoGroupFilters[0]),
			Description:     "Expand your repository filters to see results",
			ProposedQueries: proposedQueries,
		}

	case len(repoGroupFilters) == 0 && len(repoFilters) > 1:
		if globbing {
			return &alert.Alert{
				PrometheusType: "no_resolved_repos__suggest_add_remove_repos",
				Title:          "No repositories satisfied all of your repo: filters.",
				Description:    "Remove repo: filters to see results",
			}
		}
		proposedQueries := []alert.ProposedQuery{}
		unionRepoFilter := searchrepos.UnionRegExps(repoFilters)
		tryAnyRepo := searchrepos.Options{
			RepoFilters:      []string{unionRepoFilter},
			MinusRepoFilters: minusRepoFilters,
			RepoGroupFilters: repoGroupFilters,
			OnlyForks:        onlyForks,
			NoForks:          noForks,
		}
		if r.reposExist(ctx, tryAnyRepo) {
			proposedQueries = append(proposedQueries, alert.ProposedQuery{
				Description: "include repositories satisfying any (not all) of your repo: filters",
				Query:       withoutRepoFields + fmt.Sprintf(" repo:%s", unionRepoFilter),
				PatternType: r.PatternType,
			})
		}

		proposedQueries = append(proposedQueries, alert.ProposedQuery{
			Description: "remove repo: filters",
			Query:       withoutRepoFields,
		})
		return &alert.Alert{
			PrometheusType:  "no_resolved_repos__suggest_add_remove_repos",
			Title:           "No repositories satisfied all of your repo: filters.",
			Description:     "Expand your repo: filters to see results",
			ProposedQueries: proposedQueries,
		}

	case len(repoGroupFilters) == 0 && len(repoFilters) == 1:
		isSiteAdmin := backend.CheckCurrentUserIsSiteAdmin(ctx) == nil
		if !envvar.SourcegraphDotComMode() {
			if needsRepoConfig, err := needsRepositoryConfiguration(ctx, r.db); err == nil && needsRepoConfig {
				if isSiteAdmin {
					return &alert.Alert{
						Title:       "No repositories or code hosts configured",
						Description: "To start searching code, first go to site admin to configure repositories and code hosts.",
					}

				} else {
					return &alert.Alert{
						Title:       "No repositories or code hosts configured",
						Description: "To start searching code, ask the site admin to configure and enable repositories.",
					}
				}
			}
		}

		if globbing {
			return &alert.Alert{
				PrometheusType: "no_resolved_repos__generic",
				Title:          "No repositories satisfied your repo: filter",
				Description:    "Modify your repo: filter to see results",
			}
		}

		proposedQueries := []alert.ProposedQuery{}
		if forksNotSet {
			tryIncludeForks := searchrepos.Options{
				RepoFilters:      repoFilters,
				MinusRepoFilters: minusRepoFilters,
				NoForks:          false,
			}
			if r.reposExist(ctx, tryIncludeForks) {
				proposedQueries = append(proposedQueries, alert.ProposedQuery{
					Description: "include forked repositories in your query.",
					Query:       r.OriginalQuery + " fork:yes",
					PatternType: r.PatternType,
				})
			}
		}

		if archivedNotSet {
			tryIncludeArchived := searchrepos.Options{
				RepoFilters:      repoFilters,
				MinusRepoFilters: minusRepoFilters,
				OnlyForks:        onlyForks,
				NoForks:          noForks,
				OnlyArchived:     true,
			}
			if r.reposExist(ctx, tryIncludeArchived) {
				proposedQueries = append(proposedQueries, alert.ProposedQuery{
					Description: "include archived repositories in your query.",
					Query:       r.OriginalQuery + " archived:yes",
					PatternType: r.PatternType,
				})
			}
		}

		if strings.TrimSpace(withoutRepoFields) != "" {
			proposedQueries = append(proposedQueries, alert.ProposedQuery{
				Description: "remove repo: filter",
				Query:       withoutRepoFields,
				PatternType: r.PatternType,
			})
		}
		return &alert.Alert{
			PrometheusType:  "no_resolved_repos__generic",
			Title:           "No repositories satisfied your repo: filter",
			Description:     "Modify your repo: filter to see results",
			ProposedQueries: proposedQueries,
		}
	}
	// Should be unreachable. Return a generic alert if reached.
	return &alert.Alert{
		Title:       "No repository results.",
		Description: "There are no repositories to search.",
	}
}

func (r *searchResolver) alertForInvalidRevision(revision string) *alert.Alert {
	revision = strings.TrimSuffix(revision, "^0")
	return &alert.Alert{
		Title:       "Invalid revision syntax",
		Description: fmt.Sprintf("We don't know how to interpret the revision (%s) you specified. Learn more about the revision syntax in our documentation: https://docs.sourcegraph.com/code_search/reference/queries#repository-revisions.", revision),
	}
}

func (r *searchResolver) alertForOverRepoLimit(ctx context.Context) *alert.Alert {
	// Try to suggest the most helpful repo: filters to narrow the query.
	//
	// For example, suppose the query contains "repo:kubern" and it matches > 30
	// repositories, and each one of the (clipped result set of) 30 repos has
	// "kubernetes" in their path. Then it's likely that the user would want to
	// search for "repo:kubernetes". If that still matches > 30 repositories,
	// then try to narrow it further using "/kubernetes/", etc.
	//
	// (In the above sample paragraph, we assume MAX_REPOS_TO_SEARCH is 30.)
	//
	// TODO(sqs): this logic can be significantly improved, but it's better than
	// nothing for now.

	var proposedQueries []alert.ProposedQuery
	description := "Use a 'repo:' or 'repogroup:' filter to narrow your search and see results."
	if envvar.SourcegraphDotComMode() {
		description = "Use a 'repo:' or 'repogroup:' filter to narrow your search and see results or set up a self-hosted Sourcegraph instance to search an unlimited number of repositories."
	}
	if backend.CheckCurrentUserIsSiteAdmin(ctx) == nil {
		description += " As a site admin, you can increase the limit by changing maxReposToSearch in site config."
	}

	buildAlert := func(proposedQueries []alert.ProposedQuery, description string) *alert.Alert {
		return &alert.Alert{
			PrometheusType:  "over_repo_limit",
			Title:           "Too many matching repositories",
			ProposedQueries: proposedQueries,
			Description:     description,
		}
	}

	// If globbing is active we return a simple alert for now. The alert is still
	// helpful but it doesn't contain any proposed queries.
	if getBoolPtr(r.UserSettings.SearchGlobbing, false) {
		return buildAlert(proposedQueries, description)
	}

	q, err := query.ParseLiteral(r.rawQuery()) // Invariant: query is already validated; guard against error anyway.
	if err != nil || !query.IsBasic(q) {
		// If the query is not basic, the assumptions that other logic
		// makes to propose queries do not hold. Return a default alert
		// without proposed queries.
		return buildAlert(proposedQueries, description)
	}

	resolved, _ := r.resolveRepositories(ctx, nil)
	if len(resolved.RepoRevs) > 0 {
		paths := make([]string, len(resolved.RepoRevs))
		for i, repo := range resolved.RepoRevs {
			paths[i] = string(repo.Repo.Name)
		}

		// See if we can narrow it down by using filters like
		// repo:github.com/myorg/.
		const maxParentsToPropose = 4
		ctx, cancel := context.WithTimeout(ctx, 1500*time.Millisecond)
		defer cancel()
	outer:
		for i, repoParent := range pathParentsByFrequency(paths) {
			if i >= maxParentsToPropose || ctx.Err() != nil {
				break
			}
			repoParentPattern := "^" + regexp.QuoteMeta(repoParent) + "/"
			repoFieldValues, _ := r.Query.Repositories()

			for _, v := range repoFieldValues {
				if strings.HasPrefix(v, strings.TrimSuffix(repoParentPattern, "/")) {
					continue outer // this repo: filter is already applied
				}
			}

			repoFieldValues = append(repoFieldValues, repoParentPattern)
			ctx, cancel := context.WithTimeout(ctx, 500*time.Millisecond)
			defer cancel()
			resolved, err := r.resolveRepositories(ctx, repoFieldValues)
			if ctx.Err() != nil {
				continue
			} else if err != nil {
				return buildAlert([]alert.ProposedQuery{}, description)
			}

			var more string
			if resolved.OverLimit {
				more = "(further filtering required)"
			}
			// We found a more specific repo: filter that may be narrow enough. Now
			// add it to the user's query, but be smart. For example, if the user's
			// query was "repo:foo" and the parent is "foobar/", then propose "repo:foobar/"
			// not "repo:foo repo:foobar/" (which are equivalent, but shorter is better).
			newExpr := query.AddRegexpField(r.Query, query.FieldRepo, repoParentPattern)
			proposedQueries = append(proposedQueries, alert.ProposedQuery{
				Description: fmt.Sprintf("in repositories under %s %s", repoParent, more),
				Query:       newExpr,
				PatternType: r.PatternType,
			})
		}
		if len(proposedQueries) == 0 || ctx.Err() == context.DeadlineExceeded {
			// Propose specific repos' paths if we aren't able to propose
			// anything else.
			const maxReposToPropose = 4
			shortest := append([]string{}, paths...) // prefer shorter repo names
			sort.Slice(shortest, func(i, j int) bool {
				return len(shortest[i]) < len(shortest[j]) || (len(shortest[i]) == len(shortest[j]) && shortest[i] < shortest[j])
			})
			for i, pathToPropose := range shortest {
				if i >= maxReposToPropose {
					break
				}
				newExpr := query.AddRegexpField(r.Query, query.FieldRepo, "^"+regexp.QuoteMeta(pathToPropose)+"$")
				proposedQueries = append(proposedQueries, alert.ProposedQuery{
					Description: fmt.Sprintf("in the repository %s", strings.TrimPrefix(pathToPropose, "github.com/")),
					Query:       newExpr,
					PatternType: r.PatternType,
				})
			}
		}
	}
	return buildAlert(proposedQueries, description)
}

type missingRepoRevsError struct {
	Missing []*search.RepositoryRevisions
}

func (*missingRepoRevsError) Error() string {
	return "missing repo revs"
}

func newMissingRepoRevsError(missing []*search.RepositoryRevisions) error {
	a := alertForMissingRepoRevs(missing)
	a.Priority = 6
	return alert.Wrap(&missingRepoRevsError{missing}, a)
}

func alertForMissingRepoRevs(missingRepoRevs []*search.RepositoryRevisions) *alert.Alert {
	var description string
	if len(missingRepoRevs) == 1 {
		if len(missingRepoRevs[0].RevSpecs()) == 1 {
			description = fmt.Sprintf("The repository %s matched by your repo: filter could not be searched because it does not contain the revision %q.", missingRepoRevs[0].Repo.Name, missingRepoRevs[0].RevSpecs()[0])
		} else {
			description = fmt.Sprintf("The repository %s matched by your repo: filter could not be searched because it has multiple specified revisions: @%s.", missingRepoRevs[0].Repo.Name, strings.Join(missingRepoRevs[0].RevSpecs(), ","))
		}
	} else {
		sampleSize := 10
		if sampleSize > len(missingRepoRevs) {
			sampleSize = len(missingRepoRevs)
		}
		repoRevs := make([]string, 0, sampleSize)
		for _, r := range missingRepoRevs[:sampleSize] {
			repoRevs = append(repoRevs, string(r.Repo.Name)+"@"+strings.Join(r.RevSpecs(), ","))
		}
		b := strings.Builder{}
		_, _ = fmt.Fprintf(&b, "%d repositories matched by your repo: filter could not be searched because the following revisions do not exist, or differ but were specified for the same repository:", len(missingRepoRevs))
		for _, rr := range repoRevs {
			_, _ = fmt.Fprintf(&b, "\n* %s", rr)
		}
		if sampleSize < len(missingRepoRevs) {
			b.WriteString("\n* ...")
		}
		description = b.String()
	}
	return &alert.Alert{
		PrometheusType: "missing_repo_revs",
		Title:          "Some repositories could not be searched",
		Description:    description,
	}
}

// pathParentsByFrequency returns the most common path parents of the given paths.
// For example, given paths [a/b a/c x/y], it would return [a x] because "a"
// is a parent to 2 paths and "x" is a parent to 1 path.
func pathParentsByFrequency(paths []string) []string {
	var parents []string
	parentFreq := map[string]int{}
	for _, p := range paths {
		parent := path.Dir(p)
		if _, seen := parentFreq[parent]; !seen {
			parents = append(parents, parent)
		}
		parentFreq[parent]++
	}

	sort.Slice(parents, func(i, j int) bool {
		pi, pj := parents[i], parents[j]
		fi, fj := parentFreq[pi], parentFreq[pj]
		return fi > fj || (fi == fj && pi < pj) // freq desc, alpha asc
	})
	return parents
}

// Wrap an alert in a SearchResultsResolver. ElapsedMilliseconds() will
// calculate a very large value for duration if start takes on the nil-value of
// year 1. As a workaround, wrap instantiates start with time.now().
// TODO(rvantonder): #10801.
func wrapAlert(a *alert.Alert, db dbutil.DB) *SearchResultsResolver {
	return &SearchResultsResolver{db: db, alert: a}
}

func wrapSearchImplementer(a *alert.Alert, db dbutil.DB) *alertSearchImplementer {
	return &alertSearchImplementer{
		db:    db,
		alert: a,
	}
}

// alertSearchImplementer is a light wrapper type around an alert that implements
// SearchImplementer. This helps avoid needing to have a db on the searchAlert type
type alertSearchImplementer struct {
	db    dbutil.DB
	alert *alert.Alert
}

func (a alertSearchImplementer) Results(context.Context) (*SearchResultsResolver, error) {
	return wrapAlert(a.alert, a.db), nil
}

func (alertSearchImplementer) Suggestions(context.Context, *searchSuggestionsArgs) ([]SearchSuggestionResolver, error) {
	return nil, nil
}
func (alertSearchImplementer) Stats(context.Context) (*searchResultsStats, error) { return nil, nil }
func (alertSearchImplementer) Inputs() run.SearchInputs {
	return run.SearchInputs{}
}

// capFirst capitalizes the first rune in the given string. It can be safely
// used with UTF-8 strings.
func capFirst(s string) string {
	i := 0
	return strings.Map(func(r rune) rune {
		i++
		if i == 1 {
			return unicode.ToTitle(r)
		}
		return r
	}, s)
}
